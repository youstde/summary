`关键词：【惰性解析】【预解析】`

### V8 是如何执行一段 JS 代码的
1. 预解析： 检查语法错误和闭包处理
2. 生成AST： 经过语法/词法分析，生成抽象语法树
3. 生成字节码：基线编译器（Ignition）将 AST 转换为字节码
4. 由解释器逐行解释执行字节码，遇到热点代码时会启动优化编译器（Turbofan）将字节码转换成机器码

过程： `一段 JS 代码` ==解析器==> `AST 和作用域信息` ==Ignition(基线编译器)==> `字节码` ==Ignition(基线编译器)==> `解释执行`

### V8 会一次性将所有代码都编译成中间代码（字节码）吗
- *不会*
- *原因*
1. 耗时，用户会觉得卡顿
2. 占用太多内存，尤其是移动端，内存是很宝贵的资源
- *优化*
惰性解析：解析器在解析过程中，如果遇到函数声明，那么就会跳过其内部代码，并不会为其生成 AST 和字节码，而仅仅生成顶层的 AST 和字节码
- *问题*
惰性解析无法处理闭包，所以V8引入了预解析器

### 预解析器的作用
1. 检查语法错误
2. 检查函数内部是否引入外部变量，如果有引入，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包的问题

### JS 比 C++ 语言慢，JS做了什么救赎
1. 对象属性
C++ 是静态语言，在执行之前编译的时候每个对象的结构都是固定的了，因为结构是固定的，所以在编译的时候会将属性相对于该对象地址的偏移量也记录下来。那么在执行的时候就可以通过偏移量快速查找到对象上的属性。
=> JS 实现 => 隐藏类
a. 如果没有隐藏类的话，JS 获取属性需要hash查询，这个过程是很慢的。茫茫内存中去找一个地址就像大海捞针。
b. 借鉴于静态语言的偏移量，JS也搞了一个隐藏类，用来记录属性相对于该对象地址的偏移量。从而实现快速查询属性的能力
c. 归根到底，JS 还是一个动态语言，也就是说对象的结构还是可以随意改变的，新增或者删除会改变对象的结构，从而导致V8需要重新构建隐藏类，这个过程对于V8的执行效率来说是一笔大开销。

2. 优化编译器（turboFan）
对于热点代码会编译成机器码从而加速代码的执行效率，如果相同的代码被频繁执行，但是变量或者传参总是变，因为JS是弱类型语言，可以给同一个变量赋值不同类型的数据，那这段代码也不会变成热点代码

3. 内联缓存 - Inline Chche（IC）
```js
function loadX(o) { 
    return o.x
}
var o = { x: 1,y:3}
var o1 = { x: 3 ,y:6}
for (var i = 0; i < 90000; i++) {
    loadX(o)
    loadX(o1)
}
```
比如上面的代码for循环中频繁查询对象的属性
通常V8的流程是这样的：
查找对象 o 的隐藏类 => 查找到属性 x 的偏移量 => 根据偏移量获取到属性值
简化这个过程 - 内联缓存
每个函数都有自己的一个缓存，用来存储函数执行过程中的一些关键的中间数据，如果下次再执行该函数，V8就可以利用这些中间数据，从而提升一些重复代码的执行效率。
=> `IC 能提升执行效率，但是有个前提，那就是多次执行时，对象的形状（结构）是固定的` => 单态，避免多态